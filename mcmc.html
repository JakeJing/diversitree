<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>mcmc. diversitree 0.9-7</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="Richard G. FitzJohn">

<link href="css/bootstrap.css" rel="stylesheet">
<link href="css/bootstrap-responsive.css" rel="stylesheet">
<link href="css/highlight.css" rel="stylesheet">
<link href="css/staticdocs.css" rel="stylesheet">

<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
  </head>

  <body>
    <div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="brand" href="#">diversitree 0.9-7</a>
      <div class="nav">
        <ul class="nav">
          <li><a href="index.html"><i class="icon-home icon-white"></i> Index</a></li>
        </ul>
      </div>
    </div>
  </div>
</div>

    <div class="container">
      <header>
        
      </header>
      
      <h1>Simple Markov Chain Monte Carlo with Slice Sampling</h1>

<div class="row">
  <div class="span8">
    <h2>Usage</h2>
    <pre><div>mcmc(lik, x.init, nsteps, ...)
"mcmc"(lik, x.init, nsteps, w, prior=NULL, sampler=sampler.slice, fail.value=-Inf, lower=-Inf, upper=Inf, print.every=1, control=list(), save.file, save.every=0, save.every.dt=NULL, previous=NULL, previous.tol=1e-4, keep.func=TRUE, ...)</div>
<div>sampler.slice(lik, x.init, y.init, w, lower, upper, control)
sampler.norm(lik, x.init, y.init, w, lower, upper, control)</div></pre>
    
    <h2>Arguments</h2>
    <dl>
      <dt>lik</dt>
      <dd>Likelihood function to run MCMC on.  This must return the
    log likelihood (or the log of a value proportional to the
    likelihood).</dd>
      <dt>x.init</dt>
      <dd>Initial parameter location (vector).</dd>
      <dt>nsteps</dt>
      <dd>Number of MCMC steps to take.</dd>
      <dt>w</dt>
      <dd>Tuning parameter for the sampler.  See Details below for
    more information.</dd>
      <dt>prior</dt>
      <dd>An optional prior probability distribution function.
    This must be a function that returns the log prior probability,
    given a parameter vector. See <code><a href='make.prior.html'>make.prior</a></code> for more
    information.  If no prior is given, unbounded (and therefore
    &#147;improper&#148;) priors are used for all parameters, which can
    cause the MCMC to fail in some situations.</dd>
      <dt>sampler</dt>
      <dd>Sampler to use for the MCMC.  There are currently only
    two implemented; <code>sampler.slice</code> (the default, and generally
    recommended), and <code>sampler.norm</code> (Gaussian updates, and for
    illustrative purposes mostly).</dd>
      <dt>lower</dt>
      <dd>Lower bounds on parameter space (scalar or vector of same
    length as <code>x.init</code>).</dd>
      <dt>upper</dt>
      <dd>Upper bounds on parameter space (scalar or vector of same
    length as <code>x.init</code>).</dd>
      <dt>fail.value</dt>
      <dd>Value to use where function evaluation fails.  The
    default (negative infinity) corresponds to zero probability.  Most
    values that fail are invalid for a given model (negative rates, etc)
    or have negligble probability, so this is reasonable.  Set to
    <code>NULL</code> to turn off checking.</dd>
      <dt>print.every</dt>
      <dd>The position and its probability will be printed
    every <code>print.every</code> generations.  Set this to 0 to disable
    printing.</dd>
      <dt>control</dt>
      <dd>List with additional control parameters for the
    sampler.  Not currently used.</dd>
      <dt>save.file</dt>
      <dd>Name of csv or rds file to save temporary output in.
    Contents will be rewritten at each save (rds is faster than csv, but
    is R-specific).</dd>
      <dt>save.every</dt>
      <dd>Number of steps to save progress into
    <code>save.file</code>.  By default this is 0, which prevents saving
    occuring.  Low nonzero values of this will slow things down, but
    may be useful during long runs.</dd>
      <dt>save.every.dt</dt>
      <dd>Period of time to save after, as a
    <code>lubridate</code> <code>Period</code> object (e.g., <code>minutes(10)</code>).</dd>
      <dt>previous</dt>
      <dd>Output from a previous <code>mcmc</code> run, perhaps only
    partly completed.  The sampler will continue from the end of this
    chain until the total chain has <code>nsteps</code> points.</dd>
      <dt>previous.tol</dt>
      <dd>Before continuing, the sampler re-evaluates the
    last point and compares the posterior probability against the
    posterior probability in the <code>previous</code> samples.  If the
    difference is greater than <code>previous.tol</code> then <code>mcmc</code> will
    not continue.</dd>
      <dt>keep.func</dt>
      <dd>Indicates if the returned samples should include the
    likelihood function, which can be accessed with
    <code><a href='utils.html'>get.likelihood</a></code>.</dd>
      <dt>...</dt>
      <dd>Arguments passed to the function <code>lik</code></dd>
      <dt>y.init</dt>
      <dd>Likelihood evaluated at <code>x.init</code>.</dd>
    </dl>
    
    <div class="Description">
      <h2>Description</h2>
      
      <p>Run a simple-minded MCMC using slice samples (Neal 2003)
  for independent updating of each variable.</p>
  
    </div>

    <div class="Details">
      <h2>Details</h2>
      
      <p>There are two samplers implemented: a slice sampler (Neal 2003) and a
basic Gaussian sampler.  In general, only the slice sampler should be
used; the Gaussian sampler is provided for illustration and as a
starting point for future samplers.</p>
  
      <p>For slice sampling (<code>sampler.slice</code>), the tuning parameter <code>w</code>
affects how many function evaluations are required between sample
updates, but in almost all cases <strong>it does not affect how fast the
MCMC ``mixes''</strong> (Neal 2003).  In particular, <code>w</code> is not analagous
to the step sizes used in conventional Metropolis-Hastings updaters that
use some fixed kernel for updates (see below).  Ideally, <code>w</code> would
be set to approximately the width of the high probability region.  I
find that chosing the distance between the 5% and 95% quantiles of the
marginal distributions of each parameter works well, computed from this
preliminary set of samples (see Examples).  If a single value is given,
this is shared across all parameters.</p>
  
      <p>For the Gaussian updates (<code>sampler.norm</code>), the tuning parameter
<code>w</code> is the standard deviation of the normal distribution centred on
each parameter as it is updated.</p>
  
      <p>For both samplers, if a single value is given, this is shared across all
parameters.  If a vector is given, then it must be the same length as
<code>w</code>, and parameter <code>i</code> will use <code>w[i]</code>.</p>
  
      <p>If the MCMC is stopped by an interrupt (Escape on GUI versions of R,
Control-C on command-line version), it will return a truncated chain
with as many points as completed so far.</p>
  
      <p>This is far from the most efficient MCMC function possible, as it was
designed to work with likelihood functions that are relatively expensive
to compute.  The overhead for 10,000 slice samples is on the order of 5s
on a 2008 Mac Pro (0.0005 s / sample).</p>
  
      <p>The sampler function <code>sampler.norm</code> and <code>sampler.slice</code> should
not generally be called directly (though this is possible), but exist
only to be passed in to <code>mcmc</code>.</p>
  
    </div>

    <div class="References">
      <h2>References</h2>
      
      <p>Neal R.M. 2003. Slice sampling. Annals of Statistics 31:705-767.</p>
  
    </div>
    
    <h2 id="examples">Examples</h2>
    <pre class="examples"><div class='input'>## To demonstrate, start with a simple bivariate normal.  The function
## &#39;make.mvn&#39; creates likelihood function for the multivariate normal
## distribution given &#39;mean&#39; (a vector) and &#39;vcv&#39; (the variance
## covariance matrix).  This is based on mvnorm in the package
## mvtnorm, but will be faster where the vcv does not change between
## calls.
make.mvn &lt;- function(mean, vcv) {
  logdet &lt;- as.numeric(determinant(vcv, TRUE)$modulus)
  tmp &lt;- length(mean) * log(2 * pi) + logdet
  vcv.i &lt;- solve(vcv)

  function(x) {
    dx &lt;- x - mean
    -(tmp + rowSums((dx %*% vcv.i) * dx))/2
  }
}

## Our target distribution has mean 0, and a VCV with positive
## covariance between the two parameters.
vcv &lt;- matrix(c(1, .25, .25, .75), 2, 2)
lik &lt;- make.mvn(c(0, 0), vcv)

## Sample 500 points from the distribution, starting at c(0, 0).
set.seed(1)
samples &lt;- mcmc(lik, c(0, 0), 500, 1, print.every=100)
</div>
<div class='output'>100: {1.0077, 1.9016} -&gt; -4.13752
200: {-1.8865, -0.8726} -&gt; -3.54693
300: {2.7495, -0.0213} -&gt; -5.79567
400: {0.3627, 0.0973} -&gt; -1.71633
500: {-1.4309, 0.6186} -&gt; -3.36750
</div>
<div class='input'>
## The marginal distribution of V1 (the first axis of the
## distribution) should be a normal distribution with mean 0 and
## variance 1:
curve(dnorm, xlim=range(samples$X1), ylim=c(0, .5), col=&quot;red&quot;)
</div>
<p><img src='mcmc-4.png' alt='' width='400' height='400' /></p>
<div class='input'>hist(samples$X1, 30, add=TRUE, freq=FALSE)
</div>
<p><img src='mcmc-6.png' alt='' width='400' height='400' /></p>
<div class='input'>
plot(X2 ~ X1, samples, pch=19, cex=.2, col=&quot;#00000055&quot;, asp=1)
</div>
<p><img src='mcmc-8.png' alt='' width='400' height='400' /></p>
<div class='input'>
## The estimated variance here matches nicely with the true VCV: (These
## all look much better if you increase the number of sampled points,
## say to 10,000)
var(samples[2:3])
</div>
<div class='output'>          X1        X2
X1 1.2324329 0.3168768
X2 0.3168768 0.8023992
</div>
<div class='input'>
## The above uses slice sampling.  We can use simple Gaussian updates
## instead.  This performs updates with standard deviation &#39;1&#39; in each
## direction.  Unlike slice sampling, the &#39;w&#39; parameter here will
## matter a great deal in determining how fast the chain will mix.
samples.norm &lt;- mcmc(lik, c(0, 0), 500, 1, print.every=100,
                     sampler=sampler.norm)
</div>
<div class='output'>100: {0.2925, 0.2411} -&gt; -1.71384
200: {0.2392, -0.7726} -&gt; -2.18304
300: {1.0165, 0.9843} -&gt; -2.55494
400: {-0.7744, 0.7343} -&gt; -2.57660
500: {-0.5452, 0.4239} -&gt; -2.02740
</div>
<div class='input'>
## This *appears* to run much faster than the slice sampling based
## approach above, but the effective sample size of the second
## approach is much lower.  The &#39;effectiveSize&#39; function in coda says
## that for 10,000 samples using slice sampling, the effective sample
## size (equivalent number of independent samples) is about 8,500, but
## for the Gaussian updates is only 1,200.  This can be seen by
## comparing the autocorrelation between samples from the two
## different runs.  
op &lt;- par(oma=c(0, 0, 2, 0))
acf(samples[2:3])
</div>
<p><img src='mcmc-14.png' alt='' width='400' height='400' /></p>
<div class='input'>title(main=&quot;Slice sampling&quot;, outer=TRUE)
</div>
<p><img src='mcmc-16.png' alt='' width='400' height='400' /></p>
<div class='input'>
acf(samples.norm[2:3])
</div>
<p><img src='mcmc-18.png' alt='' width='400' height='400' /></p>
<div class='input'>title(main=&quot;Gaussian updates&quot;, outer=TRUE)
</div>
<p><img src='mcmc-20.png' alt='' width='400' height='400' /></p>
<div class='input'>
## The autocorrelation is negligable after just 2 samples under slice
## sampling, but remains significant for about 15 with Gaussian
## updates.

## &lt;strong&gt;Not run&lt;/strong&gt;: 
# ## Next, a diversitree likelihood example.  This example uses a 203
# ## species phylogeny evolved under the BiSSE model.  This takes a
# ## more substantial amount of time, so is not evaluated by default.
# pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
# set.seed(2)
# phy &lt;- tree.bisse(pars, max.t=60, x0=0)
# 
# ## First, create a likelihood function:
# lik &lt;- make.bisse(phy, phy$tip.state)
# lik(pars)
# 
# ## This produces about a sample a second, so takes a while.  The &quot;upper&quot;
# ## limit is a hard upper limit, above which the sampler will never let
# ## the parameter go (in effect, putting a uniform prior on the range
# ## lower..upper, and returning the joint distribution conditional on the
# ## parameters being in this range).
# tmp &lt;- mcmc(lik, pars, nsteps=100, w=.1)
# 
# ## The argument &#39;w&#39; works best when it is about the width of the &quot;high
# ## probability&quot; region for that parameter.  This takes the with of the
# ## 90% quantile range.  The resulting widths are only slightly faster
# ## than the first guess.  Samples are generated about 1/s; allow 15
# ## minutes to generate 1000 samples.
# w &lt;- diff(sapply(tmp[2:7], quantile, c(.05, .95)))
# out &lt;- mcmc(lik, pars, nsteps=1000, w=w)
# 
# ## You can do several things with this.  Look for candidate ML points:
# out[which.max(out$p),]
# 
# ## Or look at the marginal distribution of parameters
# profiles.plot(out[&quot;lambda0&quot;], col.line=&quot;red&quot;)
# 
# ## Or look at the joint marginal distribution of pairs of parameters
# plot(lambda0 ~ mu0, out)
# ## &lt;strong&gt;End(Not run)&lt;/strong&gt;

</div></pre>
  </div>
  <div class="span4">
    <!-- <ul>
      <li>mcmc</li><li>mcmc.default</li><li>sampler.slice</li><li>sampler.norm</li>
    </ul>
    <ul>
      <li>models</li>
    </ul> -->
      
    <h2>See also</h2>
    
  <code><a href='make.bd.html'>make.bd</a></code>, <code><a href='make.bisse.html'>make.bisse</a></code>,
  <code><a href='make.geosse.html'>make.geosse</a></code>, and <code><a href='make.mkn.html'>make.mkn</a></code>, all of which
  provide likelihood functions that are suitable for use with this
  function.  The help page for <code><a href='make.bd.html'>make.bd</a></code> has further
  examples of using MCMC, and <code><a href='make.bisse.html'>make.bisse</a></code> has examples of
  using priors with MCMC.

    
    <h2>Author</h2>
    Richard G. FitzJohn
    
  </div>
</div>
      
      <footer>
      <p class="pull-right"><a href="#">Back to top</a></p>
<p>Built by <a href="https://github.com/hadley/staticdocs">staticdocs</a>. Styled with <a href="http://twitter.github.com/bootstrap">bootstrap</a>.</p>
      </footer>
    </div>
  </body>
</html>