\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{Sweave}
\usepackage{natbib}
\usepackage[garamond]{mathdesign}
\usepackage{amsmath}

\usepackage{color}
\definecolor{navy}{rgb}{0,0,0.4}
\usepackage[colorlinks,citecolor=navy,linkcolor=navy,urlcolor=navy]{hyperref}

\newcommand{\code}{\texttt}
\newcommand\R{\textsf{R}}
\newcommand{\BiSSE}{\textsc{BiSSE}}
\newcommand{\MuSSE}{\textsc{MuSSE}}
\newcommand{\QuaSSE}{\textsc{QuaSSE}}
\newcommand{\diversitree}{\textsf{diversitree}}
\newcommand{\ape}{\textsf{ape}}

\SweaveOpts{prefix.string=cache/diversitree-tutorial,eps=FALSE}
<<results=hide,echo=FALSE>>=
dir.create("cache", FALSE)
@ 

<<results=hide,echo=FALSE>>=
if ( require(cacheSweave) )
  setCacheDir("cache")
@ 

% Because they look like rubbish in the final version:
<<echo=FALSE,results=hide>>=
options(show.signif.stars=FALSE)
@ 

%\VignetteIndexEntry{Introduction to diversitree}
%\VignettePackage{diversitree}

\title{Analysing diversification with \diversitree}
\author{Rich FitzJohn}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
The \diversitree\ package includes a number of comparative
phylogenetic methods, mostly focusing on analysing diversification
and character evolution.  These methods all share a common set of
utility tools for maximum likelihood (ML) parameter estimation,
hypothesis testing and model comparison, and Bayesian parameter
estimation through Markov chain Monte Carlo (MCMC).  Included methods include:

\begin{itemize}
\item \textbf{Diversification}
  \begin{itemize}
  \item Constant rate birth-death models \citep{Nee-1994-305}
  \end{itemize}

\item \textbf{Character evolution}
  \begin{itemize}
  \item Discrete trait evolution \citep{Pagel-1994-37}    
  \item Univariate Brownian motion parameter estimation for continuous
    characters
  \end{itemize}

\item \textbf{Joint character evolution and diversification}
  \begin{itemize}
  \item \BiSSE: Binary trait speciation and extinction
    \citep{Maddison-2007-701}, and extensions for incompletely
    resolved phylogenies \citep{FitzJohn-2009-595}.
  \item \MuSSE: Multiple State Speciation and Extinction.
  \item \QuaSSE: Quantitative State Speciation and Extinction:
    \citep{FitzJohn-2010-ip}
  \end{itemize}
\end{itemize}

In addition, variants of these models are available:
\begin{itemize}
\item ``Time dependent'': different time epochs have different
  parameters (implemented for \BiSSE, \MuSSE), and where rates are
  arbitrary functions of time (implemented for birth death, \BiSSE,
  and \MuSSE).
\item MEDUSA-style partitioned analyses, where different regions of
  the tree have different parameters (implemented for birth-death,
  \BiSSE, \MuSSE, and \QuaSSE).
\item Marginal ancestral state reconstruction for discrete characters
  (``Pagel94'') and \BiSSE.
\item Stochastic character mapping for discrete traits
  \citep{Bollback-2006-88}
\end{itemize}

In the future, new methods will include
\begin{itemize}
\item Reflected Brownian motion for bounded traits
\item Stochastic character mapping for discrete traits that affect
  speciation or extinction rates
\item Geographic modes of speciation (GeoSSE: Geographic State
  Speciation and Extinction: Goldberg et al. \textit{submitted})
\end{itemize}
For all methods, inference can be carried out under maximum
likelihood, or in Bayesian analyses via MCMC (Markov Chain Monte
Carlo).  Phylogenies can also be simulated under several of the
methods.

This tutorial is designed to give an overview of the features in
\diversitree.  It does not aim to be a compete reference to the
package, or claim to always follow best practice.  The manual follows
the structure above.  Many of the examples are just taken from the
online documentation; further examples can be found there.  Most are
fairly contrived -- if you have examples you would rather see here, I
would welcome data sets.

\subsection{Regenerating this file}
This file is written in ``Swears'', which allows mixing \R\ code and
\LaTeX\ markup.  If you want to regenerate the file, you will need some
data files (\url{http://www.zoology.ubc.ca/prog/diversitree/files/})
in the directory \code{data}.  Some of the code chunks take a very
long time to run (total processing time is currently about XXX hours
on a 2.8~GHz MacPro), and use the \code{cacheSweave} package to speed
subsequent runs up.  With Gregor Gorjanc's
\href{http://gregor.gorjanc.googlepages.com/Sweave.sh}{Sweave.sh}, the
file can be easily regenerated with 
\code{Sweave.sh -c -ld diversitree-tutorial.Rnw}.

<<>>=
library(diversitree)
@ 

\section{Constant-rate birth-death models}
The \ape\ package already has some support for constant-rate
birth-death models, but \diversitree\ duplicates this for
completeness.  The major differences are (1) the function is not
constrained to positive diversification rates ($\mu$ can exceed
$\lambda$), (2) support for both random taxon sampling and unresolved
terminal clades (but see \ape's \code{bd.ext}), and (3) run both MCMC
and MLE fits to birth death trees.
%
The constant rate birth death model is a special case of the other
diversification models implemented in the package, and is the simplest
model in diversitree.

Start with a simulated phylogeny, with speciation rate $\lambda=0.1$
and extinction rate $\mu=0.03$:
<<>>=
set.seed(2)
phy <- tree.bd(c(.1, .03), max.taxa=100)
@ 
%
(plotted in figure \ref{ref:bd-tree}).  The first step in any analysis
in \diversitree\ is to construct a likelihood function.  For constant
rate birth death models, this is done with \code{make.bd}:
<<>>=
lik <- make.bd(phy)
@ 
To see the argument names of the likelihood function, use the
\code{argnames} function
<<>>=
argnames(lik)
@ 
This shows that \code{lik} takes a vector of two parameters $(\lambda,
\mu)$.  It will return the log likelihood of the parameters, following
the calculations in \citep{Nee-1994-305}.
<<>>=
lik(c(.1, .03)) # -7.74086
@ 
%
Most likelihood functions accept additional arguments; these are
documented on their online help pages.  The only additional argument
accepted for birth-death model is to disable conditioning on survival
(by default, the likelihood is conditional on two lineages surviving
to the present, following \citep{Nee-1994-305}.
<<>>=
lik(c(.1, .03), condition.surv=FALSE) # -10.74823
@ 

\begin{figure}
  \centering
<<fig=TRUE,echo=FALSE,results=hide>>=
plot(phy, no.margin=TRUE, show.tip.label=FALSE)
@ 
\caption{A birth-death tree, with speciation rate $\lambda=0.1$
  and extinction rate $\mu=0.03$.}
\label{ref:bd-tree}
\end{figure}

To do a ML model fit, pass the likelihood function and a starting
point guess to the \code{find.mle} function:
<<>>=
fit <- find.mle(lik, c(.1, .03), method="subplex")
@ 
%
The final argument here selects the method ``\code{subplex}'' for the
ML search; other methods are available.  (The default for birth-death
models is ``\code{nlm}'', which may produce warnings about failure to
converge for the example here.)

To extract the coefficients from the fitted object, use the
\code{coef} function:
<<>>=
coef(fit)
@ 
and to extract the log-likelihood value at the ML point, use the
$logLik$ function
<<>>=
logLik(fit)
@ 
which extracts the coefficients with some additional information, or
extract the \code{lnLik} element from the list directly:
<<>>=
fit$lnLik
@ 

Does this model fit much better than a model without extinction (a
Yule, or pure birth, model)?  You can constrain parameters of
likelihood functions using the \code{constrain} function.  To specify
that the extinction rate, $\mu$ should be zero:
<<>>=
lik.yule <- constrain(lik, mu ~ 0)
@ 
%
Argument names here must match those given by \code{argnames}.  Run
the ML search the same way as above, specifying a single starting
parameter (I've used the speciation rate from the full model here):
<<>>=
fit.yule <- find.mle(lik.yule, coef(fit)[1], method="subplex")
@ 
To perform a likelihood ratio test, use the \code{anova}
function\footnote{This is an unfortunate convention in \R: many
  packages use this function as a general model comparison function,
  and I've taken their lead here -- in a future version, I may add a
  \code{lrt} function, which should be clearer.  No analysis of
  variance is performed.}
The model with the nonzero extinction estimate is preferred, with
$\chi^2_1=5.7$.
<<>>=
anova(fit, yule=fit.yule)
@ 

Alternatively, we can use Markov chain Monte Carlo (MCMC) to perform a
Bayesian analysis.  Here, I will use a uniform prior on the interval
$[0,\infty)$ for both parameters, by not specifying any prior.  The
\code{w} parameter is the tuning parameter.  Here, it affects how many
function evaluations will be needed per sample, but will not generally
affect the rate of mixing (see the online help for more information).
<<>>=
samples <- mcmc(lik, fit$par, nsteps=2000, w=c(.1, .1),
                lower=0, upper=Inf, print.every=1000)
@ 
The posterior distribution of these parameters, and the code to
generate it, is in figure \ref{fig:bd-mcmc}.

\begin{figure}
  \centering
<<fig=TRUE>>=
samples$r <- samples$lambda - samples$mu
col <- c("red", "blue", "green3")
profiles.plot(samples[c("lambda", "mu", "r")], col.line=col, las=1,
             ylab="Probability density", xlab="Parameter estimate")
legend("topright", c("lambda", "mu", "r"), fill=col)
abline(v=0, lty=2)
abline(v=c(.1, .03, .07), col=col)
@ 

  \caption{Posterior probability distributions for the parameters of the
    constant rate birth death model.  True values are indicated by the
    solid vertical lines.  The bars at the bottom of the distributions
    and the shaded areas correspond to the 95\% credibility
    intervals.  These include the two parameter $\lambda$ and $\mu$,
    though the true diversification rate $r$ lies above the 95\%
    credibility interval for that parameter.}
\label{fig:bd-mcmc}
\end{figure}

Analyses can also use trees where only a fraction of species are
present in the phylogeny.  To demonstrate this, let's drop 25 of the
100 species from the original tree at random:
<<>>=
set.seed(1)
phy.sub <- drop.tip(phy, sample(100, 25))
@ 
When constructing the likelihood function, pass an argument
\code{sampling.f} in, with a value on $(0,1]$ representing the
fraction of species that are descended from the root node that are
included in the phylogeny (here, $75/100$).  Then, run a ML analysis
with \code{find.mle} as before:
<<>>=
lik.sub <- make.bd(phy.sub, sampling.f=75/100)
fit.sub <- find.mle(lik.sub, c(.1, .03), method="subplex")
coef(fit.sub)
@ 

With fewer included species, test to see whether the full model is
still preferred over the Yule model:
<<>>=
lik.sub.yule <- constrain(lik.sub, mu ~ 0)
fit.sub.yule <- find.mle(lik.sub.yule, coef(fit.sub)[1],
                         method="subplex")
anova(fit.sub, yule=fit.sub.yule)
@ 
Dropping these species has reduced the support from $\chi^2_1=5.7$ to
$\chi^2_1=2.6$, and the difference is no longer significant at the 5\%
level.

\clearpage

\section{Markov models of discrete character evolution}

%% TODO: write a simulate character function, and simulate a character
%% on the BD tree above.
Again, start with a simulated tree and character distribution.  This
uses the \BiSSE simulation code, explained later, as we need both a
tree and character distribution.  This is just a 25 species
birth-death tree, with fairly high rates of character evolution of a
binary character with an asymmetry in the character transition rates,
so that $0\to 1$ transitions occur less rapidly than $1\to 0$
transitions.  The root of the tree starts in state $0$.
<<>>=
pars <- c(.1, .1, .03, .03, .1, .2)
set.seed(3)
phy <- trees(pars, "bisse", max.taxa=25, max.t=Inf, x0=0)[[1]]
states <- phy$tip.state
states
@ 
The simulation remembers the true character history, which is
displayed in figure \ref{fig:mk2-tree}.

\begin{figure}
  \centering
<<fig=TRUE>>=
par(mar=rep(0, 4))
plot(history.from.sim.discrete(phy, 0:1), phy)
@   
\caption{Character history for simulated trait and tree.  Black is
  state $0$, red is state $1$.}
  \label{fig:mk2-tree}
\end{figure}

Next, build a likelihood function with the \code{make.mk2} function,
and run a ML analysis with \code{find.mle}, using an initial parameter
guess of $(0.1, 0.1)$:
<<>>=
lik.mk2 <- make.mk2(phy, states)
fit.mk2 <- find.mle(lik.mk2, c(.1, .1), method="subplex")
coef(fit.mk2)
@ 
In the fit, the $q_{10}$ parameter is much higher than $q_{01}$; the
difference being larger than in the true model.  

See if this difference is statistically justified by running a model
where the two $q$ values are constrained to be equal:
<<>>=
lik.mk1 <- constrain(lik.mk2, q10 ~ q01)
fit.mk1 <- find.mle(lik.mk1, .1, method="subplex")
anova(fit.mk2, mk1=fit.mk1)
@ 
This is marginally significant $\chi^2_1=4.2$, so the asymmetric model
fits better.

\subsection{Drawing samples with MCMC}
It is possible to run an MCMC analysis.  However, care should be taken
to choose priors carefully, as while $q_{10}/(q_{01} + q_{10})$ is
usually well characterised by the data, the overall rate $(q_{01} +
q_{10})$ is poorly defined.  For small trees like this, essentially
infinite values of character evolution are consistent with the data,
with the tip states just drawn from the stationary distribution of the
process.

There are two supplied prior functions, but any function that takes a
vector of parameters and returns the log prior probability may be
used.  First, consider an exponential prior with rate $10$, which
gives a mean of $1/10$, and assume the same prior distribution for
both parameters.
<<>>=
prior.exp <- make.prior.exponential(10)
@ 

To run the MCMC, we need to specify a starting point (again, I have
used $(.1, .1)$, but the ML point might be preferable).  I have
discarded the first 500 samples (10\%), which is probably overkill for
this model, as the autocorrelation between samples is extremely small.
<<cache=TRUE>>=
samples <- mcmc(lik.mk2, c(.1, .1), nsteps=5000, prior=prior.exp,
                w=.1, lower=0, print.every=1000)
samples <- subset(samples, i > 500)
@ 

The marginal distributions of these parameters are shown in figure 
\begin{figure}
  \centering
<<fig=TRUE>>=
col <- c("red", "blue")
profiles.plot(samples[c("q01", "q10")], col.line=col, las=1,
              xlab="Parameter estimate",
              ylab="Posterior probability density")
abline(v=c(.1, .2), col=col)
@ 
  \caption{Posterior probability distributions for the parameters of the
    Mk2 model.  True values are indicated by the solid vertical lines.}
\label{fig:mk2-mcmc}
\end{figure}
The two marginal distributions overlap substantially, and there is
little support here for the hypothesis that $q_{10}$ is greater than
$q_{01}$.

The other prior included in \diversitree\ assumes that the mean of the
rates is exponentially distributed, and the scaled difference between
the two parameters is Beta distributed.  If we assume that the Beta
distribution is symmetrical, then its two parameters are equal, and we
have
\begin{equation*}
  \begin{split}
    \bar q = \frac{q_{01} + q_{10}}{2} \sim& \mathrm{Exp}[r]\\
    \Delta q = 1 - \frac{q_{01}}{2\bar q} \sim& \mathrm{Beta}[\beta, \beta]
  \end{split}
\end{equation*}
Specifying a exponential distribution for $\bar q$ with rate $10$ (as
before), and a uniform distribution for $\Delta q$:
<<>>=
prior.eb <- diversitree:::make.prior.ExpBeta(10, 1)
@ 
and running the MCMC sampler:
<<cache=TRUE>>=
samples.eb <- mcmc(lik.mk2, c(.1, .1), nsteps=5000, prior=prior.eb,
                w=.1, lower=0, print.every=1000)
samples.eb <- subset(samples.eb, i > 500)
@ 
The results from this are not plotted here, but give similar marginal
distributions.  However, the proportion of samples for which $q_{10} >
q_{01}$ differs between the two sets of samples.
<<>>=
mean(samples$q10 > samples$q01)
mean(samples.eb$q10 > samples.eb$q01)
@ 

\section{Binary traits and diversification: BiSSE}
The \BiSSE\ (Binary State Speciation and Extinction) model combines
the features of the constant-rates birth-death model with the
two-state Markov model.  Again, start with a simulated tree.  The
parameters here are in the order $\lambda_0$, $\lambda_1$, $\mu_0$,
$\mu_1$, $q_{01}$, $q_{10}$, so the parameters below correspond to an
asymmetry in the speciation rate where state $1$ speciates at twice
the rate as state $0$.  All other parameters are equal between states.
<<>>=
pars <- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(4)
phy <- tree.bisse(pars, max.t=30, x0=0)
states <- phy$tip.state
head(states)
@ 
This gives a 52 species tree, shown with its true history in figure
\ref{ref:bisse-tree}.  The character states are now stored in the
\code{states} vector.  This vector is named, so that each element can
be easily associated with a tip in the tree.

\begin{figure}
  \centering
<<fig=TRUE,echo=FALSE,results=hide>>=
par(mar=rep(0, 4))
plot(history.from.sim.discrete(phy, 0:1), phy)
@ 
\caption{A \BiSSE\ tree, with parameters $\lambda_0=0.1$,
  $\lambda_1=0.2$, $\mu_0=\mu_1=0.03$, and $q_{01}=q_{10}=0.01$.
  Black is state $0$, red is state $1$.}
\label{ref:bisse-tree}
\end{figure}

The \code{make.bisse} takes as its first two arguments a tree and set
of character states (these are the only mandatory arguments):
<<>>=
lik <- make.bisse(phy, states)
lik(pars) # -159.71
@ 

To perform an ML, we need a starting point.  The
\code{starting.point.bisse} function produces a basic heuristic guess
of a sensible starting point, based on the character-independent
birth-death fit.  There are no guarantees that this is at all close to
the ML point, or that the ML point can be reached from this point
while climbing uphill only (which most optimisers assume).
<<>>=
p <- starting.point.bisse(phy)
p
@

Start an ML search from this point (this may take some time)
<<cache=TRUE>>=
fit <- find.mle(lik, p)
@ 

The \code{fit.mle} object has an element \code{lnLik} with the
log-likelihood value
<<>>=
fit$lnLik
@ 
and coefficients may be extracted with \code{coef} (rounded for clarity):
<<>>=
round(coef(fit), 3)
@ 

Let's test the hypothesis that the speciation rates are different.  We
can use \code{constrain} to enforce equal speciation rates to be equal
across character states:
<<>>=
lik.l <- constrain(lik, lambda1 ~ lambda0)
@ 
and then start the ML search again:
<<>>=
fit.l <- find.mle(lik.l, p[argnames(lik.l)])
fit.l$lnLik # -158.74
@ 
%
(the statement ``\code{p[argnames(lik.l)]}'' drops the $\lambda_1$
element from the starting parameter vector).  This fit has quite
different parameters to the full model (compare $\mu_0$)
<<>>=
round(rbind(full=coef(fit), equal.l=coef(fit.l, TRUE)), 3)
@ 
(the \code{TRUE} argument forces \code{coef} to return values for
constrained parameters).  However, the difference in fits is not
statistically supported, with $chi^2_1 = 0.1$:
<<>>=
anova(fit, equal.l=fit.l)
@ 

\subsection{Analysis with MCMC}
Because we are fitting six parameters to a tree with only 52 species,
priors will be needed so that the posterior distribution is proper.  I
will use an exponential prior with rate $1/(2r)$, where $r$ is the
character independent diversification rate:
<<>>=
prior <- make.prior.exponential(1 / (2 * (p[1] - p[3])))
@ 

The MCMC sampler in \diversitree\ uses slice sampling
\citep{Neal-2003-705} for parameter updates.  The ``step size''
(argument \code{w}) does not need to be carefully tuned as it does not
affect the rate of mixing -- just the number of function evaluations
per update.  Ideally it will be on the same order as the width of the
``high probability region''.  An easy way of setting this is to run a
short chain (say, 100 steps) and use the range of observed samples as
a measure of this.
<<cache=TRUE>>=
set.seed(1)
tmp <- mcmc(lik, fit$par, nsteps=100, prior=prior,
            lower=0, w=rep(1, 6), print.every=0)
w <- diff(sapply(tmp[2:7], range))
w
@ 
Run the chain for 10,000 steps (this will take a while)
<<cache=TRUE>>=
samples <- mcmc(lik, fit$par, nsteps=10000, w=w, lower=0, prior=prior,
                print.every=1000)
@ 
The marginal distributions for the two speciation rates are shown in
figure \ref{fig:bisse-mcmc}, which shows the 95\% credibility
intervals for $\lambda_0$ completely overlapping those for
$\lambda_1$.

\begin{figure}
  \centering
<<fig=TRUE>>=
## See \link{profiles.plot} for more information on plotting these
## profiles.
col <- c("blue", "red")
profiles.plot(samples[c("lambda0", "lambda1")], col.line=col, las=1,
              xlab="Speciation rate",
              ylab="Posterior probability density")
legend("topright", c("lambda0", "lambda1"), col=col, lty=1)
abline(v=c(.1, .2), col=col)
@ 
\caption{Posterior probability distributions for $\lambda_0$ and
  $\lambda_1$ for a \BiSSE model.  True values are indicated by the
  solid vertical lines.  The bars at the bottom of the distributions
  and the shaded areas correspond to the 95\% credibility intervals.}
\label{fig:bisse-mcmc}
\end{figure}

\subsection{Incomplete taxonomic sampling}
Not all phylogenies are complete, but the basic \BiSSE\ calculations
assume that they are.  If given tree contains a random sample of all
extant species, the calculations can be corrected.  To demonstrate
this, we will generate a larger tree (150 taxa), and drop 50 taxa from
it.  Here, I am using the same parameters as earlier.
<<>>=
pars <- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(4)
phy <- tree.bisse(pars, max.taxa=150, x0=0)
states <- phy$tip.state

phy.s <- drop.tip(phy, setdiff(seq_len(150), sample(150, 50)))
states.s <- states[phy.s$tip.label]
@ 
Calculate what the sampling fraction is for this tree.  You can either
assume that the sampling fraction is independent of the character state:
<<>>=
sampling.f <- 50 / 150
@ 
or you can assume that it varies with character state
<<>>=
sampling.f <- table(states.s) / table(states)
sampling.f
@ 
Pass this in to \code{make.bisse} and construct a new likelihood
function that accounts for the sampling:
<<>>=
lik.s <- make.bisse(phy.s, phy.s$tip.state, sampling.f=sampling.f)
@ 
This can then be optimised, as before:
<<>>=
p <- starting.point.bisse(phy)
fit.s <- find.mle(lik.s, p)
fit.s[1:2]
@ 

\subsection{Terminally unresolved trees}
Another way that phylogenies might be incompletely resolved is that
higher level relationships may be known (say, genera), but little or
nothing is known about species relationships within these groups.
This results in trees where some ``taxa'' represent a number of
species -- ``terminal clades''.  There are a couple of different ways
that unresolved clade information may be specified.  To demonstrate
this, I will use an example of sexual dimorphism in shorebirds; this
is the same example as in \citep{FitzJohn-2009-595}.  The phylogeny is
a supertree constructed by \citet{Thomas-2004-28}, and the data on
sexual size dimorphism are derived from \citet{Lislevand-2007-1605}.
The required files can be downloaded from
\url{http://www.zoology.ubc.ca/prog/diversitree/files/}
Read in the phylogenetic tree
<<>>=
tree <- read.nexus("data/Thomas-tree.nex")
@ 
The tree contains many polytomies; the original tree, and a simplified
tree with polytomies converted into clades are shown in figure
\ref{fig:shorebird-tree}.
%
The character states are stored as the size of the difference of mass
between sexes, divided by the mean across sexes
\citep[see][]{FitzJohn-2009-595}.
<<>>=
states <- read.csv("data/Lislevand-states.csv", as.is=TRUE)
states <- structure(states$dimorph, names=states$species)
states <- states[tree$tip.label]
names(states) <- tree$tip.label
head(states)
@ 
These will need converting to a binary character for use, for example
-- to convert this into a binary character where an absolute relative
difference of 10\% would be considered ``dimorphic'':
<<>>=
head((abs(states) > .1) + 0)
@ 

\setkeys{Gin}{width=1.0\textwidth}
\begin{figure}
  \centering
<<fig=TRUE,width=8,height=5,echo=FALSE,results=hide>>=
## There is a lot to do here, so this is a bit of a tangle of code.
## Some of this could certainly be cleaned up and may be more
## generally useful, but that is not going to happen any time soon.
## In particular, the method of drawing grouped tip labels on plots
## *has* been generalised for radial plots, but I have not done this
## yet for normal rectangular plots.
tipmap <- function(tree, states, plt, cols, offset=0, width=1,
                   offset.y=0) {
  ## To do this, what is the order in which the labels were plotted?
  i <- tree$tip.label[order(plt$yy[1:length(tree$tip.label)])]
  is.clade <- i %in% names(tree$clades)

  ## Categorise the binary data into three classes
  states.3 <- states + 1
  states.3[is.na(states)] <- 3

  yy <- sort(plt$yy[seq_along(tree$tip.label)])

  y0.tip <- yy[!is.clade] - .5
  y1.tip <- y0.tip + 1
  col.tip <- cols[states.3[i][!is.clade]]

  if ( !is.null(tree$clades) ) {
    clades <- tree$clades[match(names(tree$clades), i[is.clade])]
    tab <- t(sapply(clades, function(x)
                    tabulate(states.3[x],3)))
    n.taxa.clade <- plt$n.taxa[names(clades)]
    loc <- t(apply(cbind(0, tab / rowSums(tab) * n.taxa.clade),
                   1, cumsum)) + yy[is.clade] - n.taxa.clade/2
    keep <- as.logical(tab > 0)
    y0.clade <- loc[,-4][keep]
    y1.clade <- loc[,-1][keep]
    col.clade <- cols[rep(1:3, each=length(clades))[keep]]
  } else {
    y0.clade <- y1.clade <- col.clade <- NULL
  }

  x0 <- max(plt$xx) + offset
  x1 <- x0 + width
  y0 <- c(y0.tip, y0.clade) + offset.y
  y1 <- c(y1.tip, y1.clade) - offset.y
  col <- c(col.tip, col.clade)
  rect(x0, y0, x1, y1, col=col, border=NA)
}

tip.label <- tree$tip.label
tree.clade <- clades.from.polytomies(tree)
n.tip <- length(tree.clade$tip.label)
cols <- c("red", "blue", "white") # 1, 0, NA
cols <- c("#E41A1C", "#377EB8", "white")

families <- read.csv("data/families.csv", as.is=TRUE)
tip.label <- tree.clade$tip.label
tip.family <- families$family[match(tip.label, families$tip)]

par(mar=rep(.5, 4), mfrow=c(1, 2))
plot(tree, show.tip.label=FALSE)
plt <- plot(tree.clade, cex=.5, label.offset=3, transform=sqrt,
            tip.color="white", clade.fill="gray")
tipmap(tree.clade, abs(states) < .15, plt, cols, 0.75, offset.y=0)

i <- order(plt$yy[1:n.tip])

xlab <- max(plt$xx[1:n.tip]) + 3
ylab <- plt$yy[i]
lab <- tip.family[i]

len <- rle(lab)$lengths
to <- cumsum(len)
from <- c(1, to[-length(to)]+1)
y0 <- ylab[from] - plt$n.taxa[i][from]/2 + 1/4
y1 <- ylab[to]   + plt$n.taxa[i][to]/2   - 1/4
ym <- (y0 + y1)/2
names(ym) <- lab[to]

fix <- match(c("Chionidae", "Thinocoridae"), lab[to])
ym[fix] <- ym[fix] + c(1.25, .25)

j <- (y1 - y0) > 1
segments(xlab-1/2, y0[j] + 0.25, xlab-1/2, y1[j] - 0.25)

text(xlab, ym, lab[to], cex=.5, adj=c(0, .5),
     font=ifelse(lab[to] == "Dromas", 3, 1))
@ 
\caption{The shorebird supertree \citep{Thomas-2004-28}.  On the left,
  the original tree with all polytomies and 350 species.  On the
  right, the polytomies have been collapsed, to leave 135 tips, with
  tips representing from 1 to 47 species.  The tips are colour coded
  to indicate state: red is sexually dimorphic, blue is monomorphic,
  and white is missing data.}
  \label{fig:shorebird-tree}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

The simplest way of working with this tree is to use the
\code{clades.from.polytomies} function.  This collapses all daughters
of any polytomy into a clade.  (Be careful - if you have a polytomy at
the base of your tree, the entire tree will collapse into a single
clade!)  This can be visualised with \code{plot} functions as normal
-- see \code{?plot.clade.tree} for more information.  This tree can
then be passed into \code{make.bisse}, along with a plain vector of
state names.  The catch is that every taxon still needs state
information, not just those at the tips.  Our state vector
\code{states} includes states for all 350 species, so we are OK to use
this.

<<>>=
states.15 <- (abs(states) > 0.15) + 0
tree.clade <- clades.from.polytomies(tree)
lik <- make.bisse(tree.clade, states.15)
@ 
A sensible starting point can still be computed with
\code{starting.point.bisse}; this takes into account the clade
information automatically.
<<>>=
p <- starting.point.bisse(tree.clade)
@ 
You can then perform a ML search or MCMC analysis as usual.  However,
unresolved clades slow down the analysis considerably, and this will
take several minutes.
<<cache=TRUE>>=
fit.full <- find.mle(lik, p)
@ 
In the full model, speciation rates for dimorphic species (state $1$)
are greater than those for monomorphic species, but character
transition rates away from dimorphism ($q_{10}$) are greater than the
reverse transition ($q_{10}$):
<<>>=
round(coef(fit.full), 3)
@ 

To test whether these differences are significant, we can use a
likelihood ratio test.  First, construct the reduced models,
constraining $\lambda_1 \sim \lambda_0$ or $q_{10} \sim q_{01}$:
<<>>=
lik.l <- constrain(lik, lambda1 ~ lambda0)
lik.q <- constrain(lik, q10 ~ q01)
@ 
Then, rerun the 
<<cache=TRUE>>=
fit.l <- find.mle(lik.l, p[argnames(lik.l)])
fit.q <- find.mle(lik.q, p[argnames(lik.q)])
@ 

These constrained models are significantly worse fits than the full
model ($p \approx 0.04$ for both).
<<>>=
anova(fit.full, equal.l=fit.l, equal.q=fit.q)
@ 

The analysis can also be run with MCMC.  Here, I am using an
exponential prior with rate $1 / (2r)$, as earlier.  This takes a very
long time to run (approximately 4--5~s/sample)
<<cache=TRUE>>=
prior <- make.prior.exponential(1 / (2*p[1]))
samples <- mcmc(lik, coef(fit.full), 10000, w=.3, prior=prior,
                print.every=0)
@ 

Setting up the likelihood function above assumed that the tree being
used contained polytomies, and this is the source of the unresolved
clades.  However, it is probably more common to have an ``exemplar''
tree, where the unresolved species were never included in the first
place.  The tree \code{Thomas-tree-exemplar.nex} (which was derived
from the tree above) does not contain any reference the species that
are contained within the unresolved clades.
<<>>=
tree.ex <- read.nexus("data/Thomas-tree-exemplar.nex")
states.ex <- states.15[tree.ex$tip.label]
names(states.ex) <- tree.ex$tip.label
@ 

We need to define a \code{data.frame} with information about the
unresolved clades.  The file \code{Thomas-unresolved.csv} contains the
information in the correct format:
<<>>=
unresolved <- read.csv("data/Thomas-unresolved.csv", as.is=TRUE)
head(unresolved)
@ 
All the columns here are required:
\begin{itemize}
\item \code{tip.label}: the tip label within the tree
\item \code{Nc}: the total number of species that the tip represents
\item \code{n0}: the number of species known to be in state $0$
\item \code{n1}: the number of species known to be in state $1$
\end{itemize}
(additional columns are fine and will be silently ignored).  Note that
\code{Nc} can be greater than \code{n0 + n1}: this allows for species
with unknown state.

This \code{unresolved} object is passed into the \code{make.bisse}
function:
<<>>=
lik.ex <- make.bisse(tree.ex, states.ex, unresolved=unresolved)
@ 

This likelihood function should be identical to the one created above.
<<>>=
lik.ex(coef(fit.full))
lik(coef(fit.full))
@ 

\section{Multiple state characters and diversification: MuSSE}
\MuSSE\ (Multiple State Speciation and Extinction) generalises the
\BiSSE\ model to allow characters with more than two states.
Following \citet{Pagel-1994-37}, this can also allow for multiple
characters, each of which might be binary, by recoding the states.


To illustrate, we'll start with a simple simulated example with a
three-level state.  The tree is simulated where character evolution is
only possible among neighbouring states (i.e., $1\to 3$ and $3\to 1$
transitions are disallowed).  All other transitions are equal, and
both speciation and extinction rates increase as the character number
increases.  For a three state case, the parameter vector is in the order
$(\lambda_1, \lambda_2, \lambda_3, \mu_1, \mu_2, \mu_3, q_{12}, q_{13},
q_{21}, q_{23}, q_{31}, q_{32})$.  This order can be seen here (sorry
-- clunky at the moment)
<<>>=
diversitree:::argnames.musse(NULL, 3)
@ 
(the order of the $q$ parameters is row-wise through the transition
rate matrix, skipping diagonal elements).

Simulate a 30 species tree, with the tree starting in state $1$.
<<>>=
pars <- c(.1,  .15,  .2,  # lambda 1, 2, 3
          .03, .045, .06, # mu 1, 2, 3
          .05, 0,         # q12, q13
          .05, .05,       # q21, q23
          0,   .05)       # q31, q32
set.seed(2)
phy <- tree.musse(pars, 30, x0=1)
@ 

The tree and its real character history are shown in figure 
\begin{figure}
  \centering
<<fig=TRUE,echo=FALSE,results=hide>>=
col <- c("blue", "orange", "red")
h <- history.from.sim.discrete(phy, 1:3)
plot(h, phy, cex=1, col=col, no.margin=TRUE, font=1)
@ 
  \caption{Simulated \MuSSE\ tree.  Blue is state 1, orange is state 2,
    and red is state 3}
\label{fig:musse-tree}
\end{figure}

The states are numbered $1,2,3$, rather than $0,1$ in \BiSSE.
<<>>=
states <- phy$tip.state
table(states)
@ 

Making a likelihood function is basically identical to \BiSSE.  The
third argument needs to be the number of states.  In a future version
this will probably be \code{max(states)}, but there are some pitfalls
about this that I am still worried about.
<<>>=
lik <- make.musse(phy, states, 3)
@ 

The argument names here are in the same order as for the simulation.
Just adding one more state (compared with \BiSSE) has moved us up to
10 parameters.
<<>>=
argnames(lik)
@ 

Rather than start with the full model, and constrain things, here I
will start with a very simple model and expand.  This model has all
$\lambda_i$, $\mu_i$, and $q_i$  the same (except for $q_{13}$ and
$q_{31}$, which are still zero).
<<>>=
lik.base <- constrain(lik, lambda2 ~ lambda1, lambda3 ~ lambda1,
                      mu2 ~ mu1, mu3 ~ mu1,
                      q13 ~ 0, q21 ~ q12, q23 ~ q12, q31 ~ 0, q32 ~ q12)
argnames(lik.base)
@ 

Find the ML point for this model
<<>>=
p <- starting.point.musse(phy, 3)
fit.base <- find.mle(lik.base, p[argnames(lik.base)])
@ 

Now, allow the speciation rates to vary
<<>>=
lik.lambda <- constrain(lik, mu2 ~ mu1, mu3 ~ mu1,
                        q13 ~ 0, q21 ~ q12, q23 ~ q12, q31 ~ 0, q32 ~ q12)
fit.lambda <- find.mle(lik.lambda, p[argnames(lik.lambda)])
@ 

There is very little improvement here (this is a small tree)
<<>>=
anova(fit.base, free.lambda=fit.lambda)
@ 

\section{\QuaSSE}

The \QuaSSE\ method is by far the slowest method in \diversitree.
This is because to compute the likelihood, we have to solve a system
of partial differential equations, which is substantially more
complicated than the system of ordinary differential equations or
simple algebraic expressions in the other methods.  The basic
interface is very similar to the other methods, but there are more
options to control the behaviour of the integrator.

<<>>=
library(diversitree)
@ 

We'll start with a simulated tree.  The tree simulation differs
slightly from the other methods, because there is no longer a
canonical argument list (speciation and extinction rates are arbitrary
functions of the character state).  
%
Here is a set of functions; speciation rate is a sigmoidal function
which ranges from $0.1$ to $0.2$ with an inflection point at $x=0$,
extinction is constant at rate $0.03$, and the model of character
evolution is Brownian motion with diffusion parameter $0.025$.
<<>>=
lambda <- function(x) sigmoid.x(x, 0.1, 0.2,  0, 2.5)
mu <- function(x) constant.x(x, 0.03)
char <- make.brownian.with.drift(0, 0.025)
@ 
Simulate the tree:

<<>>=
set.seed(1)
phy <- tree.quasse(c(lambda, mu, char), max.taxa=15, x0=0,
                   single.lineage=FALSE)
@ 

We need to specify the standard deviation for the states; here I will
just assume that all taxa have a state standard deviation of $1/200$
<<>>=
states <- phy$tip.state 
states.sd <- 1/200
@ 
Then, build the likelihood as usual.  The difference compared with
other models is that we have to specify the speciation and extinction
functions (here, \code{sigmoid.x} and \code{constant.x},
respectively).  There are a number of other provided functions (see
\code{?constant.x} for a list), but any function that takes \code{x}
as the first argument may be used.
<<>>=
lik <- make.quasse(phy, states, states.sd, sigmoid.x, constant.x)
@ 

This can be used in ML calculations as usual.  There is a
\code{starting.point.quasse} function that may be useful in selecting
sensible starting points, but some effort is still required to convert
this into a full vector as it just returns constant rate speciation,
extinction, and diffusion rates.
<<>>=
p <- starting.point.quasse(phy, states)
p
@
Let's ignore drift: the argument list we need is:
<<>>=
lik.nodrift <- constrain(lik, drift ~ 0)
argnames(lik.nodrift)
@ 
A sensible starting point here might be
<<>>=
p.start <- c(p[1], p[1], mean(states), 1, p[2:3])
names(p.start) <- argnames(lik.nodrift)
p.start
@ 
Lower bounds:
<<>>=
lower <- c(0, 0, min(states), -Inf, 0, 0)
@ 

Then run \code{find.mle}, as usual.  The \code{control} argument here
just tells the subplex algorithm to use an initial step size of 0.1
(rather than 1), which reduces the number of function evaluations
somewhat.
<<cache=TRUE>>=
fit <- find.mle(lik.nodrift, p.start, control=list(parscale=.1),
                lower=lower, verbose=0)
@ 

Compare this against the constant rate speciation fit:
<<cache=TRUE>>=
lik.constant <- constrain(lik.nodrift, l.y1 ~ l.y0, l.xmid ~ 0, l.r ~ 1)
fit.constant <- find.mle(lik.constant,
                         p.start[argnames(lik.constant)],
                         control=list(parscale=.1), lower=0,
                         verbose=0)
@ 
and compare the models -- no significant difference, which is not
surprising with only a 15 species tree.
<<>>=
anova(fit, constant=fit.constant)
@ 

\subsection{Primate analysis}
Here, I will recreate the analysis of primate diversification from
\citep{FitzJohn-2010-ip}, but fitting only speciation functions to
keep things relatively simple.
<<>>=
phy <- read.nexus("data/Vos-2006.nex")
d <- read.csv("data/Redding-2010.csv")
mass <- log(d$mass)
names(mass) <- d$tip.label
@ 

Assume standard deviation of 1/50 for all species -- this comes from
nowhere in particular, and is probably over-confident in the mass
estimates for most species.
<<>>=
mass.sd <- 1/50
@ 

Starting point parameter estimates, as above:
<<>>=
p <- starting.point.quasse(phy, mass)
p
@ 

Create a piecewise ``linear'' function.  This is linear in the range
[\code(xr[1]), \code{xr[2]}], and flat outside this range; this
satisfies the condition that the derivatives of the speciation and
extinction function with respect to the character state approach zero
at the edges of the modelled parameter space.
<<>>=
xr <- range(mass) + c(-1,1) * 20 * p["diffusion"]
linear.x <- make.linear.x(xr[1], xr[2])
@ 

Because we are going to create a reasonable number of models, here is
a function that simplifies this, requiring just speciation and
extinction functions:
<<>>=
make.primates <- function(lambda, mu)
  make.quasse(phy, mass, mass.sd, lambda, mu)
@ 
and a function that constrains drift to zero
<<>>=
nodrift <- function(f)
  constrain(f, drift ~ 0)
@ 

Create the likelihood functions where speciation is a constant, linear,
sigmoidal, or hump-shaped function of log body mass.
<<>>=
f.c <- make.primates(constant.x, constant.x)
f.l <- make.primates(linear.x, constant.x)
f.s <- make.primates(sigmoid.x, constant.x)
f.h <- make.primates(noroptimal.x, constant.x)
@ 

Start by fitting the constant model first (this will take quite a
while; each function evaluation takes about $5$~s).
<<cache=TRUE>>=
control <- list(parscale=.1, reltol=0.001)
mle.c <- find.mle(nodrift(f.c), p, lower=0, control=control,
                   verbose=0)
@ 

Starting points for the constrained analyses based on this constrained
fit.
<<>>=
p.c <- mle.c$par
p.l <- c(p.c[1], l.m=0, p.c[2:3])
p.s <- p.h <- c(p.c[1], p.c[1], mean(xr), 1, p.c[2:3])
names(p.s) <- argnames(nodrift(f.s))
names(p.h) <- argnames(nodrift(f.h))
@ 

<<cache=TRUE>>=
mle.l <- find.mle(nodrift(f.l), p.l, control=control, verbose=0)
mle.s <- find.mle(nodrift(f.s), p.s, control=control, verbose=0)
mle.h <- find.mle(nodrift(f.h), p.h, control=control, verbose=0)
@ 

And run the fits with the drift parameter added, starting from the
constrained model's ML parameters:
<<cache=TRUE>>=
mle.d.l <- find.mle(f.l, coef(mle.l, TRUE), control=control, verbose=0)
mle.d.s <- find.mle(f.s, coef(mle.s, TRUE), control=control, verbose=0)
mle.d.h <- find.mle(f.h, coef(mle.h, TRUE), control=control, verbose=0)
@ 

\begin{figure}
  \centering
<<fig=TRUE,echo=FALSE,results=hide>>=
xmin <- 2
xmax <- max(mass)

i0 <- c(1, 48, 53, 137, 153)
i1 <- c(47, 52, 136, 152, 233)

par(mfrow=c(1, 1), mar=c(2.5, .5, .5, .5), mgp=c(3, .5, 0))
plot(phy, cex=.9, label.offset=1.5, tip.color="white",
     x.lim=c(0, 107))

lastPP <- get("last_plot.phylo", envir=.PlotPhyloEnv)
xx <- lastPP$xx[1:lastPP$Ntip]
yy <- lastPP$yy[1:lastPP$Ntip]

p.h <- coef(mle.h)
y <- diff(p.h[1:2]) * .1 + p.h[1]
f <- function(x) noroptimal.x(x, p.h[1], p.h[2], p.h[3], p.h[4]) - y
peak <- c(uniroot(f, c(min(mass), p.h[3]))$root,
          uniroot(f, c(max(mass), p.h[3]))$root)

x0 <- max(xx) + 0.02 * diff(par("usr")[1:2])
x1 <- max(xx) + 0.15 * diff(par("usr")[1:2])
mass2 <- (mass - xmin) / (xmax - xmin)
mass3 <- mass2 * (x1 - x0) + x0
segments(x0, yy, mass3, yy, 
         col=ifelse(mass < peak[1] | mass > peak[2], "black", "red"))

peak3 <- (peak - xmin)/(xmax - xmin) * (x1 - x0) + x0
abline(v=peak3, lty=2)

axis.at <- pretty(c(mass, xmin, xmax))
axis.at <- axis.at[axis.at >= xmin & axis.at <= xmax]
axis(1, (axis.at - xmin)/(xmax - xmin) * (x1 - x0) + x0, axis.at, cex.axis=.7)
axisPhylo(cex.axis=.7)

dx <- diff(par("usr")[1:2])
dy <- diff(par("usr")[3:4])

text(mean(range(lastPP$xx)), min(yy) - 0.11 * dy, "Time (Ma)",
     xpd=NA, cex=.7)
text(mean(c(x1, x0)),        min(yy) - 0.11 * dy, "ln(mass)",
     xpd=NA, cex=.7)

## This is not correct.
## segments(x1 + 0.01 * dx, yy[i0]+.3, x1 + 0.01 * dx, yy[i1]-.3)
## text(x1 + 0.02 * dx, (yy[i0] + yy[i1])/2,
##     c("Strepsirhini", "Tarsiidae", "Platyrrhini", "Hominoidea",
##       "Cercopithecoidea"), cex=.7, adj=c(0, .5))
@ 
\caption{The primate tree from \citet{Vos-2006}. Log body size (in
  grams) is shown by the horizontal bar for each species \citep[data
  from][]{Redding-2010-1052}.  The vertical dashed lines indicate the
  approximate ranges of body masses in which elevated speciation rates
  were inferred, and extant species whose mass falls in this range
  have their mass coloured red.}
\label{fig:primate-tree}
\end{figure}

The fits can then be compared.  These are all against the constant
speciation rate fit (listed as ``full'' in the table).  The support is
strongest for the ``hump'' shaped fit.
<<>>=
anova(mle.c, linear=mle.l, sigmoidal=mle.s, hump=mle.h)
@ 

Next, consider splitting the tree.  MEDUSA \citep{Alfaro-2009-13410}
identified a shift in diversification rates at the base of the
superfamily Cercopithecoidea (old world monkeys).  In this tree, this
corresponds to node $153$.  It's easiest to work with node names, so
I'm going to add some here
<<>>=
phy$node.label <- paste("nd", 1:phy$Nnode, sep="")
@ 
Then, we can construct ``split'' QuaSSE objects.  For the constant
speciation rate case:
<<>>=
f.cc <- make.quasse.split(phy, mass, mass.sd, constant.x, constant.x, 
                            "nd153", Inf)
argnames(f.cc)
@ 
Here, the speciation and extinction functions may either be a single
function (as above), in which case all partitions get the same
function for speciation and extinction.  Alternatively, lists of
functions can be added, in which case different partitions may have
different functions.  The \code{Inf} indicates that the split should
go at the base of the internal edge subtending node \code{nd153},
which is consistent with MEDUSA.  Passing in 0 would put it
immediately prior to the node, and any other numeric value would place
it at that point in time from the present.

The first set of parameters refers to the ``background'' group, the
second refers refers to the ``foreground'' clade rooted at
\code{nd153}.

To simplify things, we will constrain drift to be zero and assume that
both partitions have the same diffusion coefficient.
<<>>=
g.cc <- constrain(f.cc, drift.1 ~ 0, drift.2 ~ 0, 
                  diffusion.2 ~ diffusion.1)
argnames(g.cc)
@ 

Generate a starting point from the single partition ML point:
<<>>=
p.cc <- c(p.c, p.c[1:2])
names(p.cc) <- argnames(g.cc)
@ 

At this point, the split function should have basically the same
likelihood as the single partition function:
<<cache=TRUE>>=
mle.c$lnLik - g.cc(p.cc)
@ 

And run the ML search
<<cache=TRUE>>=
mle.cc <- find.mle(g.cc, p.cc, control=control, lower=0, verbose=0)
@ 

Repeat this for linear speciation functions:
<<>>=
f.ll <- make.quasse.split(phy, mass, mass.sd, linear.x, constant.x,
                            "nd153", Inf)
g.ll <- constrain(f.ll, drift.1 ~ 0, drift.2 ~ 0, 
                  diffusion.2 ~ diffusion.1)
g.lc <- constrain(g.ll, l.m.2 ~ 0)
g.cl <- constrain(g.ll, l.m.1 ~ 0)
@ 

Generate a starting points: start with the function where both
speciation rates are linear functions.
<<>>=
p.cc <- coef(mle.cc)
p.ll <- c(p.cc[1], 0, p.cc[2:4], 0, p.cc[5])
names(p.ll) <- argnames(g.ll)
@ 

The functions with just one speciation rate as a linear function can
then be generated from this, by subsetting against the argument names
<<>>=
p.lc <- p.ll[argnames(g.lc)]
p.cl <- p.ll[argnames(g.cl)]
@ 

Run the ML searches for these models:
<<cache=TRUE>>=
mle.lc <- find.mle(g.lc, p.lc, control=control, verbose=0)
mle.cl <- find.mle(g.cl, p.cl, control=control, verbose=0)
mle.ll <- find.mle(g.ll, p.ll, control=control, verbose=0)
@ 

<<>>=
g.cl(coef(mle.ll)[argnames(g.cl)])
@ 

We can then compare the models again:
<<>>=
anova(mle.c, linear=mle.l, sigmoidal=mle.s, hump=mle.h,
      part.constant=mle.cc,
      part.linear.bg=mle.lc,
      part.linear.fg=mle.cl,
      part.linear=mle.ll)
@ 
This supports the model with a linear ``foreground'' rate of
speciation (lowest AIC value).  Looking at the coefficients for this model:
<<>>=
coef(mle.cl)
@ 
The speciation rate is a negative function of body size -- increasing
body size decreases the speciation rate.

\subsection{Controlling the calculations}

There are a number of ways to control the behaviour of the integrator:
most of these are a speed/accuracy trade-off.  These should be
supplied in the list passed in as the argument \code{control}.  The
\code{make.quasse} function attempts to select defaults that result in
acceptable performance and accuracy, but this is not always possible.

\begin{itemize}
\item \code{method}: one of \code{fftC} or \code{fftR} to switch
  between \code{C} (fast) and \R (slow) back-ends for the integration.
  Both use non-adaptive fft-based convolutions.  Eventually, an
  adaptive methods-of-lines approach will be available.
  
\item \code{dt.max}: Maximum time step to use for the integration.
  By default, this will be set to 1/1000 of the tree depth.  Smaller
  values will slow down calculations, but improve accuracy.

\item \code{nx}: The number of bins into which the character space
  is divided (default=1024).  Larger values will be slower and more
  accurate.  For the \code{fftC} integration method, this should be an
  integer power of 2 (512, 2048, etc).

\item \code{r}: Scaling factor that multiplies \code{nx} for a "high
  resolution" section at the tips of the tree (default=4, giving a
  high resolution character space divided into 4096 bins).  This helps
  improve accuracy while possibly tight initial probability
  distributions flatten out as time progresses towards the root.
  Larger values will be slower and more accurate.  For the \code{fftC}
  integration method, this should be a power of 2 (2, 4, 8, so that
  \code{nx*r} is a power of 2).
  
\item \code{tc}: where in the tree to switch to the low-resolution
  integration (zero corresponds to the present, larger numbers moving
  towards the root).  By default, this happens at 10\% of the tree
  depth.  Smaller values will be faster, but less accurate.

\item \code{xmid}: Mid point to center the character space.  By
  default this is at the mid point of the extremes of the character
  states.

\item \code{tips.combined}: Get a modest speed-up by simultaneously
  integrating all tips?  By default, this is \code{FALSE}, but
  speedups of up to 25\% are possible with this set to \code{TRUE}.

\item \code{w}: Number of standard deviations of the normal
  distribution induced by Brownian motion to use when doing the
  convolutions (default=5).  Probably best to leave this one alone.
\end{itemize}

\section{Topics not covered}

I have not covered several included models here, but information can
be found in the online documentation.  

\begin{itemize}
\item MEDUSA-style ``split'' models.  Following
  \citep{Alfaro-2009-13410}, these models allow different regions of
  the tree to have different parameters.  This is implemented for
  birth-death models (\code{make.bd.split}, which is identical to
  MEDUSA), \BiSSE\ (\code{?make.bisse.split}), and \MuSSE\
  (\code{?make.musse.split}).
\item Time-dependent models.  In these, time is divided into
  ``epochs'', each of which may have different parameters.  This is
  implemented for \BiSSE\ (\code{?make.bisse.td}) and \MuSSE\
  (\code{?make.musse.td}).  Another model of time-dependence is also
  possible, where rates are arbitrary functions of time: implemented
  for plain birth-death models (\code{?make.bd.t}), \BiSSE\
  (\code{?make.bisse.td}) and \MuSSE\ (\code{?make.musse.td}).
\item Brownian motion.  A very simple-minded Brownian motion
  likelihood calculation is included.  This allows estimation of the
  diffusion parameter of a Brownian motion process for the evolution
  of a single continuous trait (\code{?make.bm}).
\item Stochastic character mapping.  Currently implemented only for
  Markov models of discrete character evolution (?asr.stoch.mkn).
\end{itemize}

\bibliographystyle{refstyle}
\bibliography{refs}

\end{document}

% LocalWords:  Bollback ip Gorjanc's Sweave ld Rnw bd phy lik argnames surv mle
% LocalWords:  nlm coef logLik lnLik anova lrt mcmc nsteps las ylab xlab abline
% LocalWords:  topright lty mk eb rbind tmp sapply setdiff len csv dimorph plt
% LocalWords:  tipmap yy loc cbind rowSums cumsum rect mfrow cex sqrt rle ym Nc
% LocalWords:  Chionidae Thinocoridae ifelse Dromas nex musse quasse sd nodrift
% LocalWords:  parscale xmid xr lc sc noroptimal reltol xmin xmax mgp lim dx
% LocalWords:  lastPP phylo envir PlotPhyloEnv Ntip uniroot usr dy xpd ln nd dt
% LocalWords:  Tarsiidae Hominoidea Cercopithecoidea superfamily Nnode sep
% LocalWords:  fftC fftR fft nx tc bm
